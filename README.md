```markdown
# tofl-gpt-parser

## Запуск сервера

Запуск осуществляется одним из двух способов:

1. **С помощью Rust**: Если на ПК установлен **Rust**, запустите сервер командой:

   ```bash
   run --package tofl-gpt-parser --bin tofl-gpt-parser
   ```

2. **С помощью Docker**: Если установлен **Docker**, используйте следующую команду:

   ```bash
   docker run -dp 127.0.0.1:8090:8090 parser
   ```

После запуска веб-сервер будет слушать на **8090 порту**.

### Доступные пути

Сервер предоставляет два API-эндпоинта:

1. `GET /` — веб-страница для отладки.
2. `POST /parse` — сам парсер, данные передаются через **JSON**.

### Удаленный сервер

Для взаимодействия с парсером был развернут удаленный сервер, доступный по адресу:

`http://84.201.165.255:8090/`

---

## Пример входных данных

```json
{
  "TRS": "variables = x,y\nF(x) = G(y)",
  "Interpretation": "F(x) = x\nG(y) = 2*y\n"
}
```

## Пример выходных данных

```json
{
  "json_TRS": [
    {
      "left": {
        "value": "F",
        "childs": [
          {
            "value": "x",
            "childs": []
          }
        ]
      },
      "right": {
        "value": "G",
        "childs": [
          {
            "value": "y",
            "childs": []
          }
        ]
      }
    }
  ],
  "json_interpret": {
    "functions": [
      {
        "name": "F",
        "variables": ["x"],
        "expression": "(x)"
      },
      {
        "name": "G",
        "variables": ["y"],
        "expression": "(2 * y)"
      }
    ]
  }
}
```

---

## Форматирование ошибок

Парсер предусматривает обработку большого числа ошибок. Для обработки несущественных ошибок (например, несоответствие грамматике, которое можно корректно обработать и продолжить парсинг).

### Примеры формата ошибок

#### Пример 1

```json
{
  "error_trs": [
    "Ошибка в строке 1, на позиции 5, ожидалось b, считано ' '"
  ]
}
```

#### Пример 2

```plaintext
variables = x
f(g(h(i(j(k(l(m(n(o(p(x))))))))))) = q(x)
f(a,b) = c
```

```json
{
  "error_trs": [
    "Не совпадает арность функции f, ожидаемое количество аргументов: 2, считано: 1"
  ]
}
```

#### Пример 3

В примерах ниже неблокирующие ошибки аккумулируются до тех пор, пока не встретится ошибка, приводящая к завершению парсинга с ошибкой.

```plaintext
variables x, x, y
f(x = f(x)
```

```json
{
  "error_trs": [
    "Ошибка в строке 1, на позиции 10. Не хватает '=' в списке переменных",
    "Переменная x объявлена несколько раз",
    "Ошибка в строке 2, на позиции 4, ожидалось ')', считано '='"
  ]
}
```

#### Пример 4

```plaintext
TRS:
variables = x
f(x, y) = g(x)

Interpretation:
f(x, x, z) = 2
```

```json
{
  "error_interpretation": [
    "Ошибка в строке 1, на позиции 6. Переменная x уже была указана в числе аргументов данной функции",
    "Ошибка в строке 1, на позиции 10. Количество переменных в интерпретации функции f не совпадает с количеством переменных в TRS",
    "Функция g была объявлена в TRS, но её нет в интерпретации",
    "Константа y была объявлена в TRS, но её нет в интерпретации"
  ]
}
```