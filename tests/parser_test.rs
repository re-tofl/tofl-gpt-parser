use std::collections::{HashMap, HashSet};

#[cfg(test)]
mod tests {
    use std::collections::{HashMap, HashSet};
    use std::fmt::Debug;
    use tofl_gpt_parser::{models, server};
    use tofl_gpt_parser::models::data_structures::Model;
    use tofl_gpt_parser::models::ParsedData;
    use tofl_gpt_parser::parsers;
    use tofl_gpt_parser::parsers::{Parse, ParserInterpret};

    #[test]
    fn test_trs0() {
        let input = "variables = x,y\nf(x,h(y))=h(f(x,"; //EOF error
        let mut parser_trs = parsers::ParserTRS::new(input);
        match parser_trs.parse() {
            Ok(res) => {panic!("–¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å eof –æ—à–∏–±–∫–∞")}
            Err(e) => {}
        }
    }

    #[test]
    fn test_trs1() {
        let input = "variables = x,y\nf(x,h(y))=h(f(x,y))\ng = f(x,y)";
        //let input = "variables = x\ng(x) = f(f)";
        let mut parser_trs = parsers::ParserTRS::new(input);
        match parser_trs.parse() {
            Ok(res) => {}
            Err(e) => { panic!("{:?}", e) }
        }
    }

    #[test]
    fn test_trs2() {
        let input = "variables = x\ng(x) = f(f)";
        let mut parser_trs = parsers::ParserTRS::new(input);
        match parser_trs.parse() {
            Ok(res) => { panic!("–¥–æ–ª–∂–Ω–∞ –≤–µ—Ä–Ω—É—Ç—å—Å—è –æ—à–∏–±–∫–∞") }
            Err(e) => { assert_eq!(e[0], "–û—à–∏–±–∫–∞ –≤ —Å—Ç—Ä–æ–∫–µ 2, –Ω–∞ –ø–æ–∑–∏—Ü–∏–∏ 9, –æ–∂–∏–¥–∞–ª–∞—Å—å –∫–æ–Ω—Å—Ç–∞–Ω—Ç–∞ –∏–ª–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è, —Å—á–∏—Ç–∞–Ω–∞ —Ñ—É–Ω–∫—Ü–∏—è") }
        }
    }

    #[test]
    fn test_trs3() {
        let input = "variables = x\nf(x) = g\nf(x,y) = k(x)";
        let mut parser_trs = parsers::ParserTRS::new(input);
        match parser_trs.parse() {
            Ok(res) => { panic!("–¥–æ–ª–∂–Ω–∞ –≤–µ—Ä–Ω—É—Ç—å—Å—è –æ—à–∏–±–∫–∞") }
            Err(e) => { assert_eq!(e[0], "–ù–µ —Å–æ–≤–ø–∞–¥–∞–µ—Ç –∞—Ä–Ω–æ—Å—Ç—å —Ñ—É–Ω–∫—Ü–∏–∏ f, –æ–∂–∏–¥–∞–µ–º–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤: 1 , —Å—á–∏—Ç–∞–Ω–æ: 2") }
        }
    }

    #[test]
    fn test_trs4() {
        let input = "variables = x,y,x\nf(x) = g\nf(x,y) = k(x)";
        let mut parser_trs = parsers::ParserTRS::new(input);
        match parser_trs.parse() {
            Ok(res) => { panic!("–¥–æ–ª–∂–Ω–∞ –≤–µ—Ä–Ω—É—Ç—å—Å—è –æ—à–∏–±–∫–∞") }
            Err(e) => { assert_eq!(e[0], "–ü–µ—Ä–µ–º–µ–Ω–Ω–∞—è x –æ–±—ä—è–≤–ª–µ–Ω–∞ –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ä–∞–∑") }
        }
    }

    #[test]
    fn test_trs_no_equals_sign() {
        let input = "variables  x,y\nf(x) = g\nf(x,y) = k(x)";
        let mut parser_trs = parsers::ParserTRS::new(input);
        match parser_trs.parse() {
            Ok(res) => { panic!("–¥–æ–ª–∂–Ω–∞ –≤–µ—Ä–Ω—É—Ç—å—Å—è –æ—à–∏–±–∫–∞") }
            Err(e) => {
                println!("{:?}", e)
            }
        }
    }

    #[test]
    fn test_trs_deep_nesting_correct_1() {
        let input = "variables = x\na(b(c(d(e(f(x)))))) = g(h(i(j(k(l(x))))))\n";
        let mut parser_trs = parsers::ParserTRS::new(input);
        match parser_trs.parse() {
            Ok(res) => {
            }
            Err(e) => {
                panic!("{:?}", e)
            }
        }
    }

    #[test]
    fn test_trs_deep_nesting_correct_2() {
        let input = "variables = x\na(b(a(b(a(b(a(b(x)))))))) = a(x)\n";
        let mut parser_trs = parsers::ParserTRS::new(input);
        match parser_trs.parse() {
            Ok(res) => {
            }
            Err(e) => {
                panic!("{:?}", e)
            }
        }
    }

    #[test]
    fn test_trs_deep_nesting_correct_3() {
        let input = "variables = x,y,z\nf(g(h(i(j(x)))),k(l(m(n(y)))),o(p(q(r(s(z)))))) = t(u(v(w(x))))\n";
        let mut parser_trs = parsers::ParserTRS::new(input);
        match parser_trs.parse() {
            Ok(res) => { }
            Err(e) => {
                panic!("{:?}", e)
            }
        }
    }

    #[test]
    fn test_trs_deep_nesting_error_1() {
        // –ù–µ—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç –∞—Ä–Ω–æ—Å—Ç—å
        let input = "variables = x\nf(g(h(i(j(k(l(m(n(o(p(x))))))))))) = q(x)\nf(a,b) = c\n";
        let mut parser_trs = parsers::ParserTRS::new(input);
        match parser_trs.parse() {
            Ok(res) => {panic!("–¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –æ—à–∏–±–∫–∞")}
            Err(e) => { println!("{:?}", e) }
        }
    }

    #[test]
    fn test_trs_deep_nesting_error_2() {
        let input = "variables = x\na(b(c(d(e(f(g(h(i(j(k(x)))))))))) = x\n";
        // –ó–¥–µ—Å—å –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –∑–∞–∫—Ä—ã–≤–∞—é—â–∞—è —Å–∫–æ–±–∫–∞ –¥–ª—è —Ñ—É–Ω–∫—Ü–∏–∏ 'a'
        let mut parser_trs = parsers::ParserTRS::new(input);
        match parser_trs.parse() {
            Ok(res) => {panic!("–¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –æ—à–∏–±–∫–∞")}
            Err(e) => { println!("{:?}", e) }
        }
    }

    #[test]
    fn test_interpret_function_constant_not_declared() { //–§—É–Ω–∫—Ü–∏—è –±—ã–ª–∞ –æ–±—ä—è–≤–ª–µ–Ω–∞ –≤ TRS, –Ω–æ –µ—ë –Ω–µ—Ç –≤ –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏–∏
        let input1 = "F(m,n) = m+n\n";
        let mut functions = HashMap::new();
        functions.insert('F', 2);
        functions.insert('A', 1);
        let mut variables = HashSet::new();
        variables.insert('m');
        variables.insert('n');
        let mut constants = HashSet::new();
        constants.insert('p');
        let mut parser_interpret = ParserInterpret::new(input1, Model{
            variables,
            constants,
            functions,
        });

        let res = parser_interpret.parse();
        match res {
            Ok(res) => {panic!("–¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –æ—à–∏–±–∫–∞")}
            Err(e) => { println!("{:?}", e) }
        }
    }

    #[test]
    fn test_interpret_function_not_declared() { //–§—É–Ω–∫—Ü–∏—è –±—ã–ª–∞ –æ–±—ä—è–≤–ª–µ–Ω–∞ –≤ TRS, –Ω–æ –µ—ë –Ω–µ—Ç –≤ –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏–∏
        let input1 = "F(m,n) = m+n\n";
        let mut functions = HashMap::new();
        functions.insert('F', 2);
        functions.insert('A', 1);
        let mut variables = HashSet::new();
        variables.insert('m');
        variables.insert('n');
        let mut parser_interpret = ParserInterpret::new(input1, Model{
            variables,
            constants: HashSet::new(),
            functions,
        });

        let res = parser_interpret.parse();
        match res {
            Ok(res) => {panic!("–¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –æ—à–∏–±–∫–∞")}
            Err(e) => {  }
        }
    }

    #[test]
    fn test_interpret_constant_not_declared() { //–ö–æ–Ω—Å—Ç–∞–Ω—Ç–∞ –±—ã–ª–∞ –æ–±—ä—è–≤–ª–µ–Ω–∞ –≤ TRS, –Ω–æ –µ—ë –Ω–µ—Ç –≤ –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏–∏
        let input1 = "F(m,n) = m+n\n";
        let mut functions = HashMap::new();
        functions.insert('F', 2);
        let mut variables = HashSet::new();
        variables.insert('m');
        variables.insert('n');
        let mut constants = HashSet::new();
        constants.insert('p');
        let mut parser_interpret = ParserInterpret::new(input1, Model{ variables, constants, functions, });

        let res = parser_interpret.parse();
        match res {
            Ok(res) => {panic!("–¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –æ—à–∏–±–∫–∞")}
            Err(e) => { println!("{:?}", e) }
        }
    }

    #[test]
    fn test_interpret_eof_f_const() { //–æ–∂–∏–¥–∞–ª–æ—Å—å: —Ñ—É–Ω–∫—Ü–∏—è –∏–ª–∏ –∫–æ–Ω—Å—Ç–∞–Ω—Ç–∞, —Å—á–∏—Ç–∞–Ω–æ EOF
        let input1 = "";
        let mut parser_interpret = ParserInterpret::new(input1, Model{
            variables: HashSet::new(), constants: HashSet::new(), functions:HashMap::new(),
        });
        let res = parser_interpret.parse();
        match res {
            Ok(res) => {panic!("–¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –æ—à–∏–±–∫–∞")}
            Err(e) => { println!("{:?}", e) }
        }
    }

    #[test]
    fn test_interpret_expected_f_const() { //–æ–∂–∏–¥–∞–ª–æ—Å—å: —Ñ—É–Ω–∫—Ü–∏—è –∏–ª–∏ –∫–æ–Ω—Å—Ç–∞–Ω—Ç–∞, —Å—á–∏—Ç–∞–Ω–æ —á—Ç–æ-—Ç–æ
        let input1 = "üòé";
        let mut parser_interpret = ParserInterpret::new(input1, Model{
            variables: HashSet::new(), constants: HashSet::new(), functions:HashMap::new(),
        });
        let res = parser_interpret.parse();
        match res {
            Ok(res) => {panic!("–¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –æ—à–∏–±–∫–∞")}
            Err(e) => { println!("{:?}", e) }
        }
    }

    #[test]
    fn test_interpret_f_not_declared_in_trs() { //–ö–æ–Ω—Å—Ç–∞–Ω—Ç–∞ –±—ã–ª–∞ –æ–±—ä—è–≤–ª–µ–Ω–∞ –≤ TRS, –Ω–æ –µ—ë –Ω–µ—Ç –≤ –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏–∏
        let input1 = "F(m,n) = 2m+n\n";
        let mut functions = HashMap::new();
        let mut variables = HashSet::new();
        let mut constants = HashSet::new();
        let mut parser_interpret = ParserInterpret::new(input1, Model{ variables, constants, functions, });

        let res = parser_interpret.parse();
        match res {
            Ok(res) => {panic!("–¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –æ—à–∏–±–∫–∞")}
            Err(e) => { println!("{:?}", e) }
        }
    }

    #[test]
    fn test_interpret_0_coef() { //–ö–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å —Ä–∞–≤–µ–Ω 0
        let input1 = "F(m) = 0*m\n";
        let mut functions = HashMap::new();
        functions.insert('F', 1);
        let mut variables = HashSet::new();
        variables.insert('m');
        let mut constants = HashSet::new();
        let mut parser_interpret = ParserInterpret::new(input1, Model{ variables, constants, functions, });
        let res = parser_interpret.parse();
        match res {
            Ok(res) => {panic!("–¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –æ—à–∏–±–∫–∞")}
            Err(e) => { println!("{:?}", e) }
        }
    }

    #[test]
    fn test_interpret_expected_alphabetic_var() { //–û–∂–∏–¥–∞–ª–∞—Å—å –±—É–∫–≤–∞ (–≤ –Ω–∞–∑–≤–∞–Ω–∏–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π)
        let input1 = "F(m,n) = m+üî•";
        let mut functions = HashMap::new();
        functions.insert('F', 2);
        let mut variables = HashSet::new();
        variables.insert('m');
        variables.insert('n');
        let mut constants = HashSet::new();
        let mut parser_interpret = ParserInterpret::new(input1, Model{ variables, constants, functions, });
        let res = parser_interpret.parse();
        match res {
            Ok(res) => {panic!("–¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –æ—à–∏–±–∫–∞")}
            Err(e) => { println!("{:?}", e) }
        }
    }

    #[test]
    fn test_interpret_expected_bracket() { // –û–∂–∏–¥–∞–ª–æ—Å—å ',' –∏–ª–∏ ')', —Å—á–∏—Ç–∞–Ω–æ —á—Ç–æ-—Ç–æ
        let input1 = "F(m,n| = m+n";
        let mut functions = HashMap::new();
        functions.insert('F', 2);
        let mut variables = HashSet::new();
        variables.insert('m');
        variables.insert('n');
        let mut constants = HashSet::new();
        let mut parser_interpret = ParserInterpret::new(input1, Model{ variables, constants, functions, });
        let res = parser_interpret.parse();
        match res {
            Ok(res) => {panic!("–¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –æ—à–∏–±–∫–∞")}
            Err(e) => { println!("{:?}", e) }
        }
    }

    #[test]
    fn test_interpret_expected_bracket_eof() { //–æ–∂–∏–¥–∞–ª–æ—Å—å: ')' –∏–ª–∏ ',', —Å—á–∏—Ç–∞–Ω–æ EOF
        let input1 = "F(m,n";
        let mut functions = HashMap::new();
        functions.insert('F', 2);
        let mut variables = HashSet::new();
        variables.insert('m');
        variables.insert('n');
        let mut constants = HashSet::new();
        let mut parser_interpret = ParserInterpret::new(input1, Model{ variables, constants, functions, });
        let res = parser_interpret.parse();
        match res {
            Ok(res) => {panic!("–¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –æ—à–∏–±–∫–∞")}
            Err(e) => { println!("{:?}", e) }
        }
    }

    #[test]
    fn test_interpret_expected_plus() { //–æ–∂–∏–¥–∞–ª–æ—Å—å: ')' –∏–ª–∏ ',', —Å—á–∏—Ç–∞–Ω–æ EOF
        let input1 = "F(m) = m,";
        let mut functions = HashMap::new();
        functions.insert('F', 1);
        let mut variables = HashSet::new();
        variables.insert('m');
        let mut constants = HashSet::new();
        let mut parser_interpret = ParserInterpret::new(input1, Model{ variables, constants, functions, });
        let res = parser_interpret.parse();
        match res {
            Ok(res) => {panic!("–¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –æ—à–∏–±–∫–∞")}
            Err(e) => { println!("{:?}", e) }
        }
    }

    #[test]
    fn test_interpret1() {
        let input = "variables = m,n,o\nF(m,n) = G(o)";
        let input1 = "F(m,n) = m+n\nG(o) = 2*o\n";
        let mut parser_trs = parsers::ParserTRS::new(input);
        parser_trs.parse().unwrap();
        let model = Model {
            variables: parser_trs.variables,
            constants: parser_trs.constants,
            functions: parser_trs.functions,
        };
        let mut parser_interpret = ParserInterpret::new(input1, model);
        let res = parser_interpret.parse();
        match res {
            Ok(res) => {}
            Err(e) => { panic!("{:?}", e) }
        }
    }

    #[test]
    fn test_interpret2() {
        let input = "f(x)=x+1";
        let mut variables = HashSet::new();
        variables.insert('x');
        let mut functions = HashMap::new();
        functions.insert('f', 1);

        let mut parser = parsers::ParserInterpret::new(input, Model{
            variables,
            constants: Default::default(),
            functions,
        });

        match parser.parse() {
            Ok(res) => {}
            Err(e) => { panic!("{:?}", e) }
        }
    }

    #[test]
    fn test_interpret3() {
        let input = "f(x)=x+1\n";
        let mut variables = HashSet::new();
        variables.insert('x');
        let mut functions = HashMap::new();
        functions.insert('f', 1);

        let mut parser = parsers::ParserInterpret::new(input, Model{
            variables,
            constants: Default::default(),
            functions,
        });

        match parser.parse() {
            Ok(res) => {}
            Err(e) => { panic!("{:?}", e) }
        }
    }

    #[test]
    fn test_interpret4() {
        let input = "f(x)=x+1\r\n c=4\rg(x)=x+4+2*xx{3}+1";
        let mut variables = HashSet::new();
        variables.insert('x');
        let mut functions = HashMap::new();
        functions.insert('f', 1);
        functions.insert('g', 1);
        let mut constants = HashSet::new();
        constants.insert('c');


        let mut parser = parsers::ParserInterpret::new(input, Model{
            variables,
            constants,
            functions,
        });

        match parser.parse() {
            Ok(res) => {}
            Err(e) => { panic!("{:?}", e) }
        }
    }

    #[test]
    fn test_function_arity_mismatch() { //–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –≤ –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏–∏ —Ñ—É–Ω–∫—Ü–∏–∏ f –Ω–µ —Å–æ–≤–ø–∞–¥–∞–µ—Ç —Å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –≤ TRS
        let input = "f(x,y)=x";
        let mut variables = HashSet::new();
        variables.insert('x');
        variables.insert('y');
        let mut functions = HashMap::new();
        functions.insert('f', 1);
        let mut parser = parsers::ParserInterpret::new(input, Model{
            variables,
            constants: Default::default(),
            functions,
        });

        match parser.parse() {
            Ok(res) => { panic!("–¥–æ–ª–∂–Ω–∞ –≤–µ—Ä–Ω—É—Ç—å—Å—è –æ—à–∏–±–∫–∞") }
            Err(e) => {println!("{:?}", e)}
        }
    }

    #[test]
    fn test_argument_repeat_interpretation() {
        let input = "f(x,x)=x";
        let mut variables = HashSet::new();
        variables.insert('x');
        let mut functions = HashMap::new();
        functions.insert('f', 2);
        let mut parser = parsers::ParserInterpret::new(input, Model{
            variables,
            constants: Default::default(),
            functions,
        });

        match parser.parse() {
            Ok(res) => { panic!("–¥–æ–ª–∂–Ω–∞ –≤–µ—Ä–Ω—É—Ç—å—Å—è –æ—à–∏–±–∫–∞") }
            Err(e) => {println!("{:?}", e)}
        }
    }

    #[test]
    fn test_interpret6() { //–ü–µ—Ä–µ–º–µ–Ω–Ω–∞—è z –Ω–µ —É–∫–∞–∑–∞–Ω–∞ –≤ –∫–∞—á–µ—Å—Ç–≤–µ –∞—Ä–≥—É–º–µ–Ω—Ç–∞ —Ñ—É–Ω–∫—Ü–∏–∏
        let input = "f(x)=z";
        let mut variables = HashSet::new();
        variables.insert('x');
        let mut functions = HashMap::new();
        functions.insert('f', 1);


        let mut parser = parsers::ParserInterpret::new(input, Model{
            variables,
            constants: Default::default(),
            functions,
        });

        match parser.parse() {
            Ok(res) => { panic!("–¥–æ–ª–∂–Ω–∞ –≤–µ—Ä–Ω—É—Ç—å—Å—è –æ—à–∏–±–∫–∞") }
            Err(e) => {println!("{:?}", e)}
        }
    }

    #[test]
    fn test_interpret7() {
        let input = "f(z)=z";
        let mut variables = HashSet::new();
        variables.insert('x');
        let mut functions = HashMap::new();
        functions.insert('f', 1);

        let mut parser = parsers::ParserInterpret::new(input, Model{
            variables,
            constants: Default::default(),
            functions,
        });

        match parser.parse() {
            Ok(res) => {}
            Err(e) => { panic!("{:?}", e) }
        }
    }

    #[test]
    fn test_interpret8() {
        let input = "f(x, y)=2*xyx";
        let mut variables = HashSet::new();
        variables.insert('x');
        let mut functions = HashMap::new();
        functions.insert('f', 2);

        let mut parser = parsers::ParserInterpret::new(input, Model{
            variables,
            constants: Default::default(),
            functions,
        });

        match parser.parse() {
            Ok(res) => {println!("{:?}", res)}
            Err(e) => { panic!("{:?}", e) }
        }
    }

    #[test]
    fn test_interpret9() {
        let input = "f(x, y)=2*xyx+4+2+x{3}xy4*xy3*x";
        let mut variables = HashSet::new();
        variables.insert('x');
        let mut functions = HashMap::new();
        functions.insert('f', 2);

        let mut parser = parsers::ParserInterpret::new(input, Model{
            variables,
            constants: Default::default(),
            functions,
        });

        match parser.parse() {
            Ok(res) => {println!("{:?}", res)}
            Err(e) => { panic!("{:?}", e) }
        }
    }

    #[test]
    fn test_interpret10() {
        let input = "f(x, y)=xy\nk=5";
        let mut variables = HashSet::new();
        variables.insert('x');
        let mut functions = HashMap::new();
        functions.insert('f', 2);
        let mut constants = HashSet::new();
        constants.insert('k');

        let mut parser = parsers::ParserInterpret::new(input, Model{
            variables,
            constants,
            functions,
        });

        match parser.parse() {
            Ok(res) => {println!("{:?}", res)}
            Err(e) => { panic!("{:?}", e) }
        }
    }

    #[test]
    fn test_interpret11() {
        let input = "f(x, y)=xy\n f(x,y)=4\nk=1\nk=2";
        let mut variables = HashSet::new();
        variables.insert('x');
        let mut functions = HashMap::new();
        functions.insert('f', 2);
        let mut constants = HashSet::new();
        constants.insert('k');

        let mut parser = parsers::ParserInterpret::new(input, Model{
            variables,
            constants,
            functions,
        });

        match parser.parse() {
            Ok(res) => {panic!("–¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –æ—à–∏–±–∫–∞")}
            Err(e) => {  println!("{:?}", e)}
        }
    }

    #[test]
    fn test_parsers_interaction() {
        let input = "variables = x,y\nf(x,y) = k";
        let input1 = "f(x, y)=xy\nk=5";
        let mut parser_trs = parsers::ParserTRS::new(input);
        parser_trs.parse().unwrap();
        let model = Model {
            variables: parser_trs.variables,
            constants: parser_trs.constants,
            functions: parser_trs.functions,
        };
        let mut parser_interpret = ParserInterpret::new(input1, model);
        let res = parser_interpret.parse();
        match res {
            Ok(res) => {}
            Err(e) => { panic!("{:?}", e) }
        }
    }

    #[test]
    fn test_parse_eol() {
        let input = "variables = x,y\nf(x,h(y))=h(f(x,y))\n\ng = f";
        let mut parser_trs = parsers::ParserTRS::new(input);
        match parser_trs.parse() {
            Ok(res) => { panic!("–¥–æ–ª–∂–Ω–∞ –≤–µ—Ä–Ω—É—Ç—å—Å—è –æ—à–∏–±–∫–∞") }
            Err(e) => {}
        }
    }

    #[test]
    fn test_complete() {
        let headers: Vec<(String, String)> = vec![("Content-Type".to_string(), "application/json".to_string())];
        let string = "{\r\n   \"TRS\":\"variables = m,n,o\\nF(m,n) = G(o)\",\r\n   \"Interpretation\":\"F(m,n) = m+n\\nG(o) = 2*o\"\r\n}";

        let req = rouille::Request::fake_http("GET", "", headers, Vec::from(string));
        let resp = server::handlers::handle_request(&req);
        assert_eq!(resp.status_code, 200);
    }
}